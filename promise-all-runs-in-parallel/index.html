<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Does Promise.all() run tasks in parallel? - Yet another software engineer</title><link rel=icon type=image/png href=icons/myicon.png><meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:title" content="Does Promise.all() run tasks in parallel?"><meta property="og:description" content="Things will run concurrently in single-core CPU and will run in parallel in multi-core CPU. It's main task is to wait until all the promises that are passed to it are resolved."><meta property="og:type" content="article"><meta property="og:url" content="http://anotherdev.xyz/promise-all-runs-in-parallel/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-30T07:37:34+00:00"><meta property="article:modified_time" content="2019-10-30T07:37:34+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Does Promise.all() run tasks in parallel?"><meta name=twitter:description content="Things will run concurrently in single-core CPU and will run in parallel in multi-core CPU. It's main task is to wait until all the promises that are passed to it are resolved."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=http://anotherdev.xyz/css/normalize.css><link rel=stylesheet type=text/css media=screen href=http://anotherdev.xyz/css/main.css><link rel=stylesheet type=text/css href=http://anotherdev.xyz/css/custom.css><link rel=stylesheet type=text/css href=http://anotherdev.xyz/css/dark.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=http://anotherdev.xyz/js/main.js></script><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-KX5L8P2")</script></head><body><div class="container wrapper post"><div class=header><base href=http://anotherdev.xyz/><h1 class=site-title><a href=http://anotherdev.xyz/>Yet another software engineer</a></h1><div class=site-description><h2>My thoughts are my own</h2><nav class="nav social"><ul class=flat><a href=https://github.com/shihabmridha title=Github><i data-feather=github></i></a><a href=https://twitter.com/shihabmridha title=Twitter><i data-feather=twitter></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=http://anotherdev.xyz/>Home</a></li><li><a href=http://anotherdev.xyz/posts>All notes</a></li><li><a href=http://anotherdev.xyz/about>About</a></li><li><a href=http://anotherdev.xyz/tags>Tags</a></li></ul></nav></div><div class=post-header><h1 class=title>Does Promise.all() run tasks in parallel?</h1><div class=meta>Posted at &mdash; Oct 30, 2019</div></div><div class=markdown><p><strong><em>TL; DR</em></strong></p><p><strong>No!</strong> More accurately, it <strong>depends on various factors</strong>.</p><hr><p>The promise API is a blessing for JavaScript developers. It makes writing asynchronous JavaScript a lot easier. Go to hell <strong>callback</strong>! Like some other JavaScript concepts promise confuses a lot of people. I am not going to talk about promise in this article. There are tons of articles related to promise.</p><p>There is a misconception about <strong><a href=https://en.wikipedia.org/wiki/Concurrency_(computer_science)>concurrency</a></strong> and <strong>parallelism</strong> in the JavaScript world. When the promise got introduced people started to think that now everything is now going to run in parallel. I have found that this is not completely true.</p><h3 id=lets-talk-about-some-important-fundamentals-briefly>Let&rsquo;s talk about some <strong>important fundamentals</strong> (briefly)</h3><p>A single-core CPU can not perform multiple tasks at the same time. So, it means it is not possible to get parallelism in a single-core CPU. Then how does my single-core CPU perform multiple tasks at the same time? Well, there are a lot of things going on in the operating system but there are two main concepts. One is <a href=https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)>multi-threading</a> and another one is <a href=https://en.wikipedia.org/wiki/Context_switch>context switching</a>. Multiple tasks are handled by multiple threads. What happens is the CPU performs one task (using a thread) for a certain time and then pause the current task and move on to the next task (using another thread) and start processing it. This switching happens so fast that we think everything is running in parallel even though we are using a single-core CPU.
But, the modern computer has dedicated hardware for I/O (network, file read/write, etc). There is a concept called DMA (direct memory access) that allows the computer to perform I/O without blocking the CPU. It means, when we are dealing with network or reading/writing in the SSD/HDD, our CPU is mostly sitting idle. It is the fundamental concept behind the creation of Node.JS. Now, if we think about it we can achieve parallelism where CPU would do one thing at the same time I/O would do something else.</p><blockquote><p>A single-core CPU can not perform multiple tasks at the same time.</p></blockquote><h3 id=writing-async-infront-of-a-function-does-not-make-it-asynchronous>Writing <code>async</code> infront of a function does not make it asynchronous</h3><p>It is very important to understand that writing <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function><code>async</code> infront of a function or returning a promise from a function</a> does not make the function nonblocking/asynchronous. See the example below:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#268bd2>async</span> <span style=color:#268bd2>function</span> isPrime(num) {
</span></span><span style=display:flex><span>  <span style=color:#719e07>for</span>(<span style=color:#268bd2>var</span> i <span style=color:#719e07>=</span> <span style=color:#2aa198>2</span>; i <span style=color:#719e07>&lt;</span> num; i<span style=color:#719e07>++</span>)
</span></span><span style=display:flex><span>    <span style=color:#719e07>if</span>(num <span style=color:#719e07>%</span> i <span style=color:#719e07>===</span> <span style=color:#2aa198>0</span>) <span style=color:#719e07>return</span> <span style=color:#cb4b16>false</span>;
</span></span><span style=display:flex><span>  <span style=color:#719e07>return</span> num <span style=color:#719e07>&gt;</span> <span style=color:#2aa198>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>var</span> isItPrime <span style=color:#719e07>=</span> <span style=color:#268bd2>await</span> isPrime(<span style=color:#2aa198>89098977</span>); <span style=color:#586e75>// Blocking operation
</span></span></span></code></pre></div><p>The function above returns a promise but it is a pure cpu intensive operation. So, whenever we will call the function the CPU won&rsquo;t be able to process anything else. Which means it blocks the event loop.</p><h3 id=whats-up-with-promiseall>What&rsquo;s up with Promise.all</h3><p><code>Promise.all</code> doesn&rsquo;t guarantee us to run things in parallel. In fact, <code>Promise.all</code> is only reliable for waiting until all the promises given to it are resolved. It&rsquo;s job is to ensure that no promises get passed until they are done with their job. Is it confusing? Let&rsquo;s try with some examples.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#586e75>// getResultsFromDatabase() returns promise and does not contains blocking operation
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#268bd2>const</span> promise1 <span style=color:#719e07>=</span> getResultsFromDatabase(user1);
</span></span><span style=display:flex><span><span style=color:#268bd2>const</span> promise2 <span style=color:#719e07>=</span> getResultsFromDatabase(user2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>const</span> [res1, res2] <span style=color:#719e07>=</span> <span style=color:#268bd2>await</span> <span style=color:#b58900>Promise</span>.all(promise1, promise2);
</span></span><span style=display:flex><span>processData(res1, res2);
</span></span></code></pre></div><p>Take a look at the code above carefully. Both <code>getResultsFromDatabase</code> functions started executing before executing the 3rd line. The third line ensures that <code>processData</code> doesn&rsquo;t get executed until both the promises are done.</p><p>You can achieve the same result without using <code>Promise.all</code>. Example:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#268bd2>const</span> promise1 <span style=color:#719e07>=</span> getResultsFromDatabase(user1);
</span></span><span style=display:flex><span><span style=color:#268bd2>const</span> promise2 <span style=color:#719e07>=</span> getResultsFromDatabase(user2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>const</span> res1 <span style=color:#719e07>=</span> <span style=color:#268bd2>await</span> promise1;
</span></span><span style=display:flex><span><span style=color:#268bd2>const</span> res2 <span style=color:#719e07>=</span> <span style=color:#268bd2>await</span> promise2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>processData(res1, res2);
</span></span></code></pre></div><p>The same thing happens here. <code>getResultsFromDatabase</code> gets executed immediately and then waits for them to resolve. <code>Promise.all</code> will return a reject promise if any of the given promises gets rejected. But, the reject will contain the reason for the first reject event if multiple reject happen.</p><h3 id=how-would-promiseall-behave>How would Promise.all behave?</h3><p>Depending on the &ldquo;Task/CPU&rdquo; it might run in parallel or concurrently or sequentially. In single-core CPU the promises would run concurrently and in multi-core CPU they can be executed (!) in parallel for CPU intensive tasks. As explained earlier that most of the modern computers can do I/O in parallel. So, it is kind of safe to assume that network call, file read/write, etc tasks can run in parallel with cpu.</p><h3 id=last-words>Last words</h3><p>JavaScript runtime is single-threaded. We do not have access to thread in JavaScript (recent version of NodeJS allows us to create thread using worker_threads module). Even if we have multi-core CPU we still can&rsquo;t run cpu intensive tasks in parallel directly using JavaScript. But, the browser/NodeJS uses C/C++ (!) where they have access to thread. So, they can achieve parallelism (ex: NodeJS&rsquo;s crypto module).</p></div><div class=post-tags><nav class="nav tags"><ul class=flat><li><a href=http://anotherdev.xyz/tags/javascript>javascript</a></li><li><a href=http://anotherdev.xyz/tags/concurrency>concurrency</a></li><li><a href=http://anotherdev.xyz/tags/parallelism>parallelism</a></li></ul></nav></div></div><div class="footer wrapper"><nav class=nav><div>© Another Dev | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script>feather.replace()</script></body></html>